Thread API的详细介绍：
    线程sleep：
        sleep是一个静态方法，其有两个重载方法，其中一个需要传入毫秒数，另外一个既需要毫秒数也需要纳秒数。
        sleep方法介绍：
            public static native void sleep(long millis) throws InterruptedException
            public static void sleep(long millis, int nanos)throws InterruptedException
            sleep方法会使当前线程进入指定毫秒数的休眠，暂停执行，虽然给定了一个休眠的时间，但是最终要以系统的定时器
        和调度器的精度为准，休眠有一个非常重要的特性，那就是其不会放弃monitor锁的所有权
    使用TimeUnit替代Thread.sleep:
        在JDK1.5以后，JDK引入了一个枚举TimeUnit，其对sleep方法提供了很好的封装，使用它可以省去时间单位的换算步骤，
    比如线程想休眠3小时24分17秒88毫秒，使用TimeUnit来实现就非常的简便优雅了:
        Thread.sleep(12257088L);
        TimeUnit.HOURS.sleep(3);
        TimeUnit.MINUTES.sleep(24);
        TImeUnit.SECOND.sleep(17);
        TimeUnit.MILLISECONDS.sleep(88);
        同样的时间表达，TimeUnit显然清晰很多，建议，在使用Thread.sleep的地方，完全使用TimeUnit来代替，因为sleep
    能做的事，TimeUnit全部都能完成，并且功能更加强大。
    线程yield:
        yield方法介绍：
            yield方法属于一种启发式的方法，其会提醒调度器我愿意放弃当前的CPU资源，如果CPU的资源不紧张，则会忽略这种
        提醒。调用yield方法会使当前线程从RUNNING状态切换到RUNNABLE状态，一般这个方法不太常用。
    yield和sleep
        在JDK1.5以前的版本中yield的方法事实上是调用了sleep(0),但是它们之间存在着本质的区别，具体如下：
            1.sleep会导致当前线程暂停指定的时间，没有CPU时间片的消耗。
            2.yield只是对CPU调度器的一个提示，如果CPU调度器没有忽略这个提示，它会导致线程上下文的切换。
            3.sleep会使线程短暂block，会在给定的时间内释放CPU资源。
            4.yield会使RUNNABLE状态的Thread进入RUNNABLE状态(如果CPU调度器没有忽略这个提示的话)。
            5.sleep几乎百分之百地完成了给定时间的休眠，而yield的提示并不能一定担保。
            6.一个线程sleep另一个线程调用interrupt会捕获到中断信号，而yield则不会。
    设置线程的优先级：
        1.public final void setPriority(int newPriority)为线程设定优先级。
        2.public final int getPriority()获取线程的优先级。
    线程优先级介绍：
        进程有进程的优先级，线程同样也有优先级，理论上是优先级比较高的线程会优先获取被CPU调度的机会，但是事实上往往并
    不会如你所愿，设置线程的优先级同样也是一个hint操作，具体如下：
        1.对于root用户，它会hint操作系统你想要设置的优先级别，否则它会被忽略。
        2.如果CPU比较忙，设置优先级可能会获得更多的CPU时间片，但是闲时优先级的高低几乎不会有任何作用。
    线程优先级源码分析：
        设置线程的优先级，只需要调用setPriority方法即可，下面我们打开Thread源码，一起来分析一下：
        public final void setPriority(int newPriority) {
            ThreadGroup g;
            checkAccess();
            if (newPriority > MAX_PRIORITY || newPriority < MIN_PRIORITY) {
                throw new IllegalArgumentException();
            }
            if((g = getThreadGroup()) != null) {
                if (newPriority > g.getMaxPriority()) {
                    newPriority = g.getMaxPriority();
                }
                setPriority0(priority = newPriority);
            }
        }
        线程的优先级不能小于1也不能大于10，如果指定的线程优先级大于线程所在group的优先级，那么指定的优先级将会失效，取
    而代之的是group的最大优先级。
    获取线程ID:
        public long getId()获取线程的唯一ID,线程的ID在整个JVM进程中都会是唯一的，并且是从0开始逐次递增。如果你在
    main线程中创建了一个唯一的线程，并且调用getId()后发现其并不等于0，这是因为在一个JVM进程启动的时候，实际上是开辟
    了很多个线程，自增序列已经有了一定的消耗，因此我们自己创建的线程绝非第0号线程。
    获取当前线程：
        public static native Thread currentThread()用于返回当前执行线程的引用，这个方法虽然很简单，但是使用广泛。


